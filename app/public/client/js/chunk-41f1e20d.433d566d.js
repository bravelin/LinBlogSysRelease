(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-41f1e20d"],{"3ad6":function(e,t,n){"use strict";var o=function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div")},r=[],a=(n("f763"),n("eb57")),i={data:function(){return{catalog:[],showPreview:!1,previewList:[],previewIndex:0}},mounted:function(){var e=this;e.$store.commit(a["a"].SWITCH_LOADING,!1),e.$nextTick(function(){window.addEventListener("scroll",e.doHandlerScroll);var t=document.querySelectorAll("code");t.length>0&&t.forEach(function(e){hljs.highlightBlock(e)});var n=document.querySelectorAll("h3.title");if(n.length>0){var o=[],r=Math.round(1e6*Math.random()),a="";e.catalog=n.forEach(function(e,t){a="section"+r+"-"+t,e.setAttribute("id",a),o.push({text:e.innerHTML,id:a,el:e,active:!1})}),e.catalog=o}var i=document.querySelectorAll(".content figure>img");i.length>0&&e.getImageSize(0,i)})},methods:{getImageSize:function(e,t){var n=this,o=new Image,r=t[e];o.onload=function(){n.previewList.push({src:r.src,w:this.width,h:this.height}),e++,e<t.length?n.getImageSize(e,t):n.$el.addEventListener("click",n.doPreview)},o.src=r.src},doPreview:function(e){var t=this;if(/img/i.test(e.target.tagName)&&!t.showPreview&&!e.target.classList.contains("pswp__img")){t.previewIndex=0;for(var n=0;n<t.previewList.length;n++)if(t.previewList[n].src==e.target.src){t.previewIndex=n;break}t.showPreview=!0}},doHandlerScroll:function(){for(var e,t,n=this,o=n.catalog.length-1;o>=0;o--)if(e=n.catalog[o].el,e.getBoundingClientRect().top<10){t=o;break}n.catalog=n.catalog.map(function(e,n){return e.active=n==t,e})}},beforeDestroy:function(){var e=this;window.removeEventListener("scroll",e.doHandlerScroll),e.previewList.length>0&&e.$el.removeEventListener("click",e.doPreview)}},l=i,v=n("6691"),c=Object(v["a"])(l,o,r,!1,null,null,null);t["a"]=c.exports},"9fe4":function(e,t,n){"use strict";n.r(t);var o=function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",{staticClass:"page-container article-page"},[n("h2",{staticClass:"title"},[e._v("ES6标准入门笔记之二：变量的解构赋值")]),e._m(0),n("footer",[e._v("2017年03月09日")]),n("Comments"),n("Catalog",{attrs:{catalog:e.catalog}})],1)},r=[function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",{staticClass:"content"},[n("h3",{staticClass:"title"},[e._v("数组的解构赋值")]),n("p",[n("strong",[e._v("Destructuring")]),e._v("：按照一定模式，从数组和对象中提取值，对变量进行赋值，称之为解构。")]),n("pre",[n("code",[e._v("var [a, b, c] = [1, 2, 3]\n\nvar [a, ...b] = [1, 2, 3, 4]\nconsole.log(a) // 1\nconsole.log(b) // [2, 3, 4]")])]),n("p",[e._v("上面按照位置的对应关系对变量赋值。这种写法属于\n                "),n("strong",[e._v("模式匹配")]),e._v("，只要等号两边的模式相同，左边的变量就会被赋予对应的值。")]),n("p",[e._v("如果解构不成功，变量的值为undefined。不完全解构也是支持的。")]),n("pre",[n("code",[e._v("let [x, y] = [1, 2, 3]")])]),n("p",[e._v("如果等号的右边不是数组（不是可遍历的结构），那么将会报错。")]),n("p",[e._v("对于Set结构以及具有Iterator接口的数据结构，也可以使用数组的解构赋值：")]),n("pre",[n("code",[e._v("let [x, y, z] = new Set(['a', 'b', 'c'])")])]),n("p",[n("strong",[e._v("解构赋值允许指定默认值：")]),e._v("当相应的位置值严格等于undefined时，变量值取默认值。")]),n("pre",[n("code",[e._v("[x, y = 'b'] = ['a', undefined] // x = 'a'  y = 'b'\n[x = 1] = [null] // x = null")])]),n("p",[e._v("如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候才会求值。")]),n("p",[e._v("默认值可以引用解构赋值的其他变量，但该变量必须已经赋值：")]),n("pre",[n("code",[e._v("let [x = 1, y = x] = [] // x=1; y=1\nlet [x = 1, y = x] = [2] // x=2; y=2")])]),n("h3",{staticClass:"title"},[e._v("对象的解构赋值")]),n("p",[e._v("对象的解构相同的属性名为依据获取正确的值，未能获取则值为undefined：")]),n("pre",[n("code",[e._v("var { foo, bar } = { foo: '111', bar: '222' } // foo = '111' bar = '222'")])]),n("p",[e._v("上式真正的形式为：")]),n("pre",[n("code",[e._v("var { foo: foo, bar: bar } = { foo: '111', bar: '222' } // foo = '111' bar = '222'")])]),n("p",[e._v("其内部机制是先找到同名属性，然后再赋值给对应的变量。真正被赋值的不是属性，而是变量。")]),n("p",[e._v("和数组一样，解构也可用于嵌套结构的对象。")]),n("pre",[n("code",[e._v("let obj = {}\nlet arr = []\n({ foo : obj.prop, bar : arr[0] } = { foo: 123, bar: true } ) // obj = { prop: 123 }  arr = [true]")])]),n("p",[e._v("对象的解构也可以指定默认值，条件是对象的属性值严格等于undefined。")]),n("p",[e._v("未能成功解构，对象的值为undefined。")]),n("p",[e._v("如果将一个已经声明的变量用于解构赋值，必须非常小心：")]),n("pre",[n("code",[e._v("// 错误的写法\nvar x\n{ x } = { x: 1 }\n\n// 正确的写法\n({ x } = { x: 1 })")])]),n("p",[e._v("对象的解构赋值可以将现有对象的方法赋值到某个变量：let { sin, cos, log } = Math")]),n("h3",{staticClass:"title"},[e._v("字符串的解构赋值")]),n("p",[e._v("字符串也可以解构赋值，此时字符串被转换成了一个类似数组的对象：")]),n("pre",[n("code",[e._v("const [a, b, c, d, e] = 'hello'\na // 'h'\nb // 'e'")])]),n("p",[e._v("类似数组的对象都有length属性，可以对这个属性进行解构赋值：")]),n("pre",[n("code",[e._v("let { length: len } = 'hello'\nlen // 5")])]),n("h3",{staticClass:"title"},[e._v("数值和布尔值的解构赋值")]),n("p",[e._v("如果等号右边的是数值或者布尔值，则会先转换成对象：")]),n("pre",[n("code",[e._v("let { toString: s } = 123\ns === Number.prototype.toString // true\n\nlet { toString: s } = true\ns === Boolean.prototype.toString // true\n            ")])]),n("p",[n("strong",[e._v("解构赋值的规则是，只要等号右边的值不是对象，则会先转换成对象。undefined和null无法转换成对象，所以对它们的解构赋值都会报错。")])]),n("h3",{staticClass:"title"},[e._v("函数参数的解构赋值")]),n("p",[e._v("函数的参数也可以解构赋值：")]),n("pre",[n("code",[e._v("[[1, 2], [3, 4]].map(([a, b] => a+b)) // [3, 7]")])]),n("p",[e._v("也可以使用默认值：")]),n("pre",[n("code",[e._v("function move({x = 0, y = 0} = {}) { return [x, y] }\nmove({ x: 3, y: 8}) // [3, 8]\nmove({ x: 3}) // [3, 0]")])]),n("p",[e._v("参数是一个对象，对这个对象进行解构，得到变量x和y的值。如果解构失败，则x和y等于默认值。")]),n("p",[e._v("下面的写法为参数指定默认值，而不是为变量x和y指定默认值，注意区分写法：")]),n("pre",[n("code",[e._v("function move({ x, y } = { x: 0, y: 0 }) { return [x, y] }\nmove({x: 3, y: 8}) // [3, 8]\nmove({x: 3}) // [3, undefined]\nmove() // [0,0]")])]),n("p",[n("strong",[e._v("undefined会触发函数参数的默认值。")])]),n("h3",{staticClass:"title"},[e._v("圆括号的问题")]),n("p",[e._v("ES6的规则是，只要有可能导致解构奇异，就不得使用圆括号。不能使用圆括号的情况：")]),n("p",[n("strong",[e._v("1、变量声明语句中，模式不能带有圆括号；")])]),n("p",[n("strong",[e._v("2、函数参数中，模式不能带有圆括号；")])]),n("p",[n("strong",[e._v("3、不能将整个模式或者嵌套模式中的一层放在括号中；")])]),n("p",[e._v("可以使用圆括号的情况：\n                "),n("strong",[e._v("赋值语句的非模式部分可以使用圆括号：")])]),n("h3",{staticClass:"title"},[e._v("用途")]),n("p",[n("strong",[e._v("1、交换变量的值：[x, y] = [y, x]")])]),n("p",[n("strong",[e._v("2、从函数返回多个值")])]),n("pre",[n("code",[e._v("function exp() { return [1, 2, 3] }\nvar [a, b, c] = exp()")])]),n("p",[n("strong",[e._v("3、函数参数的定义")])]),n("pre",[n("code",[e._v("function f([x, y, z]) { ... }\nf([1, 2, 3])\n\nfunction f({x, y, z}) { ... }\nf({ x: 1, y: 2, z: 3 })")])]),n("p",[n("strong",[e._v("4、提取JSON数据对象")])]),n("p",[n("strong",[e._v("5、函数参数的默认值")])]),n("p",[n("strong",[e._v("6、遍历Map结构：")])]),n("pre",[n("code",[e._v("var map = new Map()\nmap.set('first', 'hello')\nmap.set('second', 'world')\nfor(let [key, value] of map) { console.log(key + ' is ' +value) }")])]),n("p",[n("strong",[e._v("7、输入模块的指定方法：")])]),n("pre",[n("code",[e._v("const { SourceNode } = require('source-map')")])])])}],a=n("3ad6"),i={extends:a["a"]},l=i,v=n("6691"),c=Object(v["a"])(l,o,r,!1,null,null,null);t["default"]=c.exports}}]);