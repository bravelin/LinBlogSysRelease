(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-e8a1fe24"],{"3ad6":function(r,e,t){"use strict";var n=function(){var r=this,e=r.$createElement,t=r._self._c||e;return t("div")},a=[],i=(t("4634"),t("eb57")),o={data:function(){return{catalog:[],showPreview:!1,previewList:[],previewIndex:0}},mounted:function(){var r=this;r.$store.commit(i["a"].SWITCH_LOADING,!1),r.$nextTick((function(){window.addEventListener("scroll",r.doHandlerScroll);var e=document.querySelectorAll("code");e.length>0&&e.forEach((function(r){hljs.highlightBlock(r)}));var t=document.querySelectorAll("h3.title");if(t.length>0){var n=[],a=Math.round(1e6*Math.random()),i="";r.catalog=t.forEach((function(r,e){i="section"+a+"-"+e,r.setAttribute("id",i),n.push({text:r.innerHTML,id:i,el:r,active:!1})})),r.catalog=n}var o=document.querySelectorAll(".content figure>img");o.length>0&&r.getImageSize(0,o)}))},methods:{getImageSize:function(r,e){var t=this,n=new Image,a=e[r];n.onload=function(){t.previewList.push({src:a.src,w:this.width,h:this.height}),r++,r<e.length?t.getImageSize(r,e):t.$el.addEventListener("click",t.doPreview)},n.src=a.src},doPreview:function(r){var e=this;if(/img/i.test(r.target.tagName)&&!e.showPreview&&!r.target.classList.contains("pswp__img")){e.previewIndex=0;for(var t=0;t<e.previewList.length;t++)if(e.previewList[t].src==r.target.src){e.previewIndex=t;break}e.showPreview=!0}},doHandlerScroll:function(){for(var r,e,t=this,n=t.catalog.length-1;n>=0;n--)if(r=t.catalog[n].el,r.getBoundingClientRect().top<10){e=n;break}t.catalog=t.catalog.map((function(r,t){return r.active=t==e,r}))}},beforeDestroy:function(){var r=this;window.removeEventListener("scroll",r.doHandlerScroll),r.previewList.length>0&&r.$el.removeEventListener("click",r.doPreview)}},v=o,s=t("4e82"),y=Object(s["a"])(v,n,a,!1,null,null,null);e["a"]=y.exports},4634:function(r,e,t){for(var n=t("96dd"),a=t("7d56"),i=t("a6d5"),o=t("3f8b"),v=t("b8ea"),s=t("e3b3"),y=t("1277"),f=y("iterator"),p=y("toStringTag"),_=s.Array,u={CSSRuleList:!0,CSSStyleDeclaration:!1,CSSValueList:!1,ClientRectList:!1,DOMRectList:!1,DOMStringList:!1,DOMTokenList:!0,DataTransferItemList:!1,FileList:!1,HTMLAllCollection:!1,HTMLCollection:!1,HTMLFormElement:!1,HTMLSelectElement:!1,MediaList:!0,MimeTypeArray:!1,NamedNodeMap:!1,NodeList:!0,PaintRequestList:!1,Plugin:!1,PluginArray:!1,SVGLengthList:!1,SVGNumberList:!1,SVGPathSegList:!1,SVGPointList:!1,SVGStringList:!1,SVGTransformList:!1,SourceBufferList:!1,StyleSheetList:!0,TextTrackCueList:!1,TextTrackList:!1,TouchList:!1},l=a(u),c=0;c<l.length;c++){var d,A=l[c],g=u[A],w=o[A],b=w&&w.prototype;if(b&&(b[f]||v(b,f,_),b[p]||v(b,p,A),s[A]=_,g))for(d in n)b[d]||i(b,d,n[d],!0)}},b865:function(r,e,t){"use strict";t.r(e);var n=function(){var r=this,e=r.$createElement,t=r._self._c||e;return t("div",{staticClass:"page-container article-page"},[t("h2",{staticClass:"title"},[r._v("ES6标准入门笔记之十一：二进制数组")]),r._m(0),t("footer",[r._v("2017年05月18日")]),t("Comments"),t("Catalog",{attrs:{catalog:r.catalog}})],1)},a=[function(){var r=this,e=r.$createElement,t=r._self._c||e;return t("div",{staticClass:"content"},[t("p",[r._v("二进制数组是JS操作二进制数据的接口。其目的是方便浏览器（WebGL）与显卡之间进行大量的、实时的交换数据。类似C语言的数组，可以直接操作内存。包括以下3类对象：")]),t("p",[t("strong",[r._v("ArrayBuffer对象")]),r._v("：代表内存中的一段二进制数据，可以通过“视图”进行操作。")]),t("p",[t("strong",[r._v("TypedArray对象")]),r._v("：共包括9种类型的视图，包括Int8、Uint8、Uint8C、Int16、Uint16、Int32、Uint32、Float32、Float64，主要用于读写简单类型的二进制数据。")]),t("p",[t("strong",[r._v("DataView对象")]),r._v("：自定义复合格式的视图。")]),t("h3",{staticClass:"title"},[r._v("ArrayBuffer对象")]),t("p",[r._v("代表存储二进制数据的一段内存，\n                "),t("strong",[r._v("不能直接读写，只能通过视图进行读写。")]),r._v("同时也是一个构造函数，用于分配一段可以存放数据的连续区域：")]),t("pre",[t("code",[r._v("var buf = new ArrayBuffer(bytes) // bytes代表字节数，每个字节默认值为0")])]),t("p",[r._v("使用DataView读取ArrayBuffer：")]),t("pre",[t("code",[r._v("var buf = new ArrayBuffer(32)\nvar dataView = new DataView(buf)\ndataView.getUint8(0) // 无符号8位整数格式读取：0")])]),t("p",[r._v("TypedArray视图是一组构造函数，代表不同的数据格式：")]),t("pre",[t("code",[r._v("var buffer = new ArrayBuffer(12)\nvar x1 = new Int32Array(buffer) // 32位带符号整数\nx1[0] = 1\nvar x2 = new Uint8Array(buffer) // 8位无符号整数\nx2[0] = 2\nx1[0] // 2")])]),t("p",[r._v("ArrayBuffer实例的byteLength属性，返回所分配的内存区域字节长度。如果要分配的内存区域很大，有可能分配失败，因此有必要检查是否分配成功：")]),t("pre",[t("code",[r._v("if (buf.byteLength == n) {\n    // 分配成功\n} else {\n    // 分配失败\n}")])]),t("p",[r._v("ArrayBuffer实例的slice()方法，可以将内存区域的一部分复制生成一个新的ArrayBuffer对象：")]),t("pre",[t("code",[r._v("var buf = new ArrayBuffer(8)\nvar newBuf = buf.slice(0, 3) // 复制前3个字节")])]),t("p",[r._v("slice方法的第一个参数表示复制开始的字节序号（含该字节），第二个参数表示复制结束的字节序号（不含，默认到结尾）。")]),t("p",[t("strong",[r._v("ArrayBuffer.isView()")]),r._v("，静态方法，判断参数是否为ArrayBuffer的视图实例：")]),t("pre",[t("code",[r._v("var buf = new ArrayBuffer(32)\nvar v = new Int32Array(buf)\nArrayBuffer.isView(v) // true")])]),t("h3",{staticClass:"title"},[r._v("TypedArray视图")]),t("p",[r._v("TypedArray视图一共包括9种类型，每一种视图都是一种构造函数：")]),t("p",[t("strong",[r._v("1、Int8Array")]),r._v("：8位有符号整数；")]),t("p",[t("strong",[r._v("2、Uint8Array")]),r._v("：8位无符号整数；")]),t("p",[t("strong",[r._v("3、Uint8ClampedArray")]),r._v("：8位无符号整数，溢出处理不同；")]),t("p",[t("strong",[r._v("4、Int16Array")]),r._v("：16位有符号整数；")]),t("p",[t("strong",[r._v("5、Uint16Array")]),r._v("：16位无符号整数；")]),t("p",[t("strong",[r._v("6、Int32Array")]),r._v("：32位有符号整数；")]),t("p",[t("strong",[r._v("7、Uint32Array")]),r._v("：32位无符号整数；")]),t("p",[t("strong",[r._v("8、Float32Array")]),r._v("：32位浮点数；")]),t("p",[t("strong",[r._v("9、Float64Array")]),r._v("：64位浮点数；")]),t("p",[r._v("普通数组与TypedArray数组的区别：")]),t("p",[t("strong",[r._v("1、TypedArray数组的所有成员都是同一种类型；")])]),t("p",[t("strong",[r._v("2、TypedArray数组的成员是连续的，不会有空位；")])]),t("p",[t("strong",[r._v("3、TypedArray数组成员的默认值是0.")])]),t("p",[t("strong",[r._v("4、TypedArray数组只是一层视图，本身不储存数据。")])]),t("p",[r._v("构造函数原型：\n                "),t("strong",[r._v("TypedArray(buffer, byteOffset=0, length?)")]),r._v("：第一个参数必须，指向底层ArrayBuffer对象；第二个可选，视图开始的字节序号，默认为0；第三个可选，视图包含的数据个数，默认到内存区域结尾。")]),t("p",[r._v("注意，byteOffset必须与所要建立的数据类型一致，否则会报错：")]),t("pre",[t("code",[r._v("var buf = new ArrayBuffer(32)\nvar v = new Int16Array(buf, 1) // ERROR")])]),t("p",[r._v("如果需要从任意字节开始解读ArrayBuffer对象，必须使用DataView视图。")]),t("p",[t("strong",[r._v("TypedArray(length)")]),r._v("：视图还可以不通过ArrayBuffer，直接分配内存生成。")]),t("pre",[t("code",[r._v("var f64a = new Float64Array(8) // 64字节")])]),t("p",[t("strong",[r._v("TypedArray(typedArray)")]),r._v("：接收另外一个TypedArray实例作为参数构造生成，此时新数组会开辟新的内存区域储存数据，不会在原数组的内存区域之上建立视图。")]),t("pre",[t("code",[r._v("var x = new Int8Array([1, 1])\nvar y = new Int8Array(x)")])]),t("p",[r._v("如果想基于相同的内存区域构造不同的视图，可以这样写：")]),t("pre",[t("code",[r._v("var x = new Int8Array([1, 1])\nvar y = new Int8Array(x.buffer)")])]),t("p",[t("strong",[r._v("TypedArray(arrayLikeObj)")]),r._v("：构造函数的参数也可以是一个普通数组，直接生成TypedArray实例。此时会重新开辟内存区域。")]),t("p",[t("strong",[r._v("字节序")]),r._v("：指的是数值在内存中的表示方式：")]),t("pre",[t("code",[r._v("var buf = new ArrayBuffer(16)\nvar int32View = new Int32Array(buf)\nfor (var i = 0; i < int32View.length; i++) {\n    int32View[i] = i * 2\n}\nconsole.log(int32View) // 0 2 4 6\nvar int16View = new Int16Array(buf)\nconsole.log(int16View) // 0 0 2 0 4 0 6 0")])]),t("p",[r._v("x86体系的计算机都采用\n                "),t("strong",[r._v("小端字节序（litter endian），相对重要的字节（高字节）排在后面，不重要的字节（低字节）排在前面。大端字节序列则相反。TypedArray内部也采用小端字节序列读写。DataView对象可以设定字节序列。")])]),t("p",[r._v("下面的方法可以判断当前视图是否是小端字节序，还是大端字节序：")]),t("pre",[t("code",[r._v("const BIG_ENDIAN = Symbol('BIG_ENDINA')\nconst LITTER_ENDINA = Symbol('LITTER_ENDINA')\nfunction getPlatformEndianness() {\n    let arr32 = Uint32Array.of(0x12345678)\n    let arr8 = new Uint8Array(arr32.buffer)\n    switch ((arr8[0]*0x1000000) + (arr8[1]*0x10000) + (arr8[2]*0x100)+(arr8[3])) {\n        case 0x12345678: return BIG_ENDIAN;\n        case 0x78563412: return LITTER_ENDINA;\n        default: throw new Error('Unknow endianness')\n    }\n}")])]),t("p",[r._v("每一种TypedArray视图，都有一个BYTES_PER_ELEMENT属性，表示这种数据类型占据的字节数：")]),t("pre",[t("code",[r._v("Int8Array.BYTES_PER_ELEMENT // 1\nFloat64Array.BYTES_PER_ELEMENT // 8")])]),t("p",[r._v("ArrayBuffer与字符串的相互转换：（前提是字符串的编码方法是确定的，比如UTF-16）")]),t("pre",[t("code",[r._v("// ArrayBuffer转为字符串\nfunction ab2str(buf) {\n    return String.fromCharCode.apply(null, new Uint16Array(buf))\n}\n// 字符串转为ArrayBuffer\nfunction str2ab(str) {\n    var buf = new ArrayBuffer(str.length * 2)\n    var bufView = new Uint16Array(buf)\n    for(var i = 0; i < str.length; i++) {\n        bufView[i] = str.charCodeAt(i)\n    }\n    return buf\n}")])]),t("p",[t("strong",[r._v("正向溢出(overflow)")]),r._v("：输入值大于当前数据类型的最大值时，最后得到的值是当前数据类型的最小值加上余值，再减去1；\n                "),t("strong",[r._v("负向溢出(underflow)")]),r._v("：输入值小于当前数据类型的最小值时，当前数据类型的最大值减去余值，再加上1。")]),t("pre",[t("code",[r._v("var uint8 = new Uint8Array(1)\nuint8[0] = 256 // 0\nuint8[0] = -1 // 255\nvar int8 = new Int8Array(1)\nint8[0] = 128 // -128\nint8[0] = -129 // 127")])]),t("p",[t("strong",[r._v("Uint8ClampedArray")]),r._v("视图的溢出与上面的规则不同，正向溢出都等于255，负向溢出都等于0：")]),t("pre",[t("code",[r._v("var uint8c = new Uint8ClampedArray(1)\nuint8c[0] = 256 // 255\nuint8c[0] = -1 // 0")])]),t("p",[t("strong",[r._v("TypedArray.prototype.buffer")]),r._v("：返回整段内存区域对应的ArrayBuffer对象。")]),t("p",[t("strong",[r._v("TypedArray.prototype.byteLength")]),r._v("：返回数组占据的内存长度。")]),t("p",[t("strong",[r._v("TypedArray.prototype.length")]),r._v("：返回数组的成员数目。")]),t("p",[t("strong",[r._v("TypedArray.prototype.byteOffset")]),r._v("：返回数组从底层ArrayBuffer对象的哪个字节开始。")]),t("p",[t("strong",[r._v("TypedArray.prototype.set()")]),r._v("：用于复制数组（普通数组或者TypedArray数组）,将一段内存完全复制到另外一段内存,可以指定从哪个位置开始复制。")]),t("pre",[t("code",[r._v("var a = new Uint8Array(8)\nvar b = new Uint8Array(10)\nb.set(a, 2) // 从a[2]开始")])]),t("p",[t("strong",[r._v("TypedArray.prototype.subarray()")]),r._v("：对于TypedArray的一部分再建立一个新的视图，第1个参数是起始的字节序号，第2个参数是结束成员序号（不包含）：")]),t("pre",[t("code",[r._v("var a = new Uint8Array(8)\nvar b = a.subarray(2,3)\nb.byteLength // 1")])]),t("p",[t("strong",[r._v("TypedArray.prototype.slice()")]),r._v("：返回一个指定位置的新的TypedArray实例，支持负值：")]),t("pre",[t("code",[r._v("let uint8 = Uint8Array.of(1,2,3)\nuint8.slice(-1) // [3]")])]),t("p",[t("strong",[r._v("TypedArray.of()")]),r._v("：静态方法，用于将参数转为一个TypedArray实例。")]),t("pre",[t("code",[r._v("Float32Array.of(0.1,0.2,3)")])]),t("p",[r._v("TypedArray的构造方法：")]),t("pre",[t("code",[r._v("let a1 = new Uint8Array([1,2,3])\nlet a2 = new Uint8Array.of(1,2,3)\nlet a3 = new Uint8Array(3)\na3[0] = 1\na3[1] = 2\na3[2] = 3")])]),t("p",[t("strong",[r._v("TypedArray.from()")]),r._v("：接受一个可遍历的结构（比如数组）作为参数，返回一个基于此结构的TypedArray实例。")]),t("pre",[t("code",[r._v("Uint16Array.from([0,1,2])")])]),t("p",[r._v("还可以将一种TypedArray转为另外一种：")]),t("pre",[t("code",[r._v("var uint16 = Uint16Array.from(Uint8Array.of(1,2,3))")])]),t("p",[r._v("还可以接受一个函数作为第二个参数，对每个元素进行遍历：")]),t("pre",[t("code",[r._v("Int16Array.from(Int8Array.of(1,2,3), x => 2*x) // [2,4,6]")])]),t("h3",{staticClass:"title"},[r._v("复合视图")]),t("p",[r._v("视图的构造函数可以指定起始位置和长度，所以在同一段内存中可以依次存放不同类型的数据：")]),t("pre",[t("code",[r._v("var buf = new ArrayBuffer(24)\nvar idView = new Uint32Array(buf,0,1) // 字节0~3：1个32位无符号整数\nvar userNameView = new Uint8Array(buf,4,16) // 字节4~19：16个8位无符号整数\nvar amountView = new Float32Array(buf, 20, 1) // 字节20~23:1个32位浮点数")])]),t("h3",{staticClass:"title"},[r._v("DataView视图")]),t("p",[r._v("DataView支持设定字节序，接受一个ArrayBuffer对象作为参数生成视图。")]),t("pre",[t("code",[r._v("var buf = new ArrayBuffer(32)\nvar dv = new DateView(buf, 2, 4) // 支持设定起始位置和长度")])]),t("p",[r._v("DataView实例的\n                "),t("strong",[r._v("buffer、byteLength、byteOffset")]),r._v("属性与TypedArray含义一致。")]),t("p",[r._v("DataView实例提供以下8个方法读取内存：\n                "),t("strong",[r._v("getInt8、getUint8、getInt16、getUint16、getInt32、getUint32、getFloat32、getFloat64")]),r._v("，方法的参数是一个字节序号，表示读取的起始位置：")]),t("pre",[t("code",[r._v("var buf = new ArrayBuffer(32)\nvar dv = new DataView(buf)\nvar v1 = dv.getUint8(0) // 从第0个字节读取一个uint8\nvar v2 = dv.getUint16(1) // 从第1个字节读取一个uint16")])]),t("p",[r._v("如果一次读取两个或者两个以上的字节，则必须明确数据的储存方式，是小端序列还是大端序列（默认），如果是小端序列，第2个参数需要设定为true：")]),t("pre",[t("code",[r._v("var v3 = dv.getUint8(4, true)")])]),t("p",[r._v("DataView提供以下8个方法写入内存：\n                "),t("strong",[r._v("setUint8、setInt8、setUint16、setInt16、setInt32、setUint32、setFloat32、setFloat64")]),r._v("，接受3个参数，第1个参数表示写入的位置，第2个参数是写入的数据，第3个参数表面数据的储存方式（大小端）：")]),t("pre",[t("code",[r._v("dv.setUint32(0, 32, true)")])])])}],i=t("3ad6"),o={extends:i["a"]},v=o,s=t("4e82"),y=Object(s["a"])(v,n,a,!1,null,null,null);e["default"]=y.exports}}]);